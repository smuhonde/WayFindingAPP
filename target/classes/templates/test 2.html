<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Drawing App with Paths and Resizable Images</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 0;
        }
        #mapCanvas {
            border: 1px solid #333;
            cursor: crosshair;
        }
        #toolbar {
            margin: 10px 0;
        }
        #toolbar button, #toolbar input {
            margin: 0 5px;
        }
    </style>
</head>
<body>


<!-- Toolbar for controls -->
<div id="toolbar">
    <button onclick="startGeolocation()">Locate Me</button>
    <label>Color:</label>
    <input type="color" id="colorPicker" value="#ff0000">
    <label>Line Width:</label>
    <input type="range" id="lineWidth" min="1" max="10" value="3">
    <button onclick="clearCanvas()">Clear Canvas</button>
    <button onclick="saveCanvas()">Save Map</button>
    <input type="file" id="imageUpload" accept="image/*">
</div>

<!-- Canvas for drawing -->
<canvas id="mapCanvas" width="800" height="600"></canvas>

<script>
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    let startX = 0, startY = 0;
    let currentX = 0, currentY = 0;
    let lines = [];
    let images = [];
    let selectedImage = null;
    let draggingImage = null;
    let resizing = false;
    let resizeHandleSize = 8;

    const colorPicker = document.getElementById('colorPicker');
    const lineWidth = document.getElementById('lineWidth');
    const imageUpload = document.getElementById('imageUpload');

    // Drawing path setup
    canvas.addEventListener('mousedown', (e) => {
        if (selectedImage) {
            if (isOverResizeHandle(e.offsetX, e.offsetY, selectedImage)) {
                resizing = true;
                return;
            }
        }
        startX = e.offsetX;
        startY = e.offsetY;
        isDrawing = true;
    });

    canvas.addEventListener('mousemove', (e) => {
        if (resizing && selectedImage) {
            selectedImage.width = e.offsetX - selectedImage.x;
            selectedImage.height = e.offsetY - selectedImage.y;
            drawCanvas();
            return;
        }

        if (!isDrawing) return;
        currentX = e.offsetX;
        currentY = e.offsetY;
        if (Math.abs(currentX - startX) > Math.abs(currentY - startY)) {
            currentY = startY;
        } else {
            currentX = startX;
        }
        drawCanvas();
        ctx.strokeStyle = colorPicker.value;
        ctx.lineWidth = lineWidth.value;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(currentX, currentY);
        ctx.stroke();
    });

    canvas.addEventListener('mouseup', () => {
        if (resizing) {
            resizing = false;
            return;
        }
        if (!isDrawing) return;
        isDrawing = false;
        lines.push({ startX, startY, endX: currentX, endY: currentY, color: colorPicker.value, width: lineWidth.value });
        startX = currentX;
        startY = currentY;
        drawCanvas();
    });

    // Image upload and handling
    imageUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const img = new Image();
        img.src = URL.createObjectURL(file);
        img.onload = () => {
            images.push({ img, x: 50, y: 50, width: 100, height: 100 });
            drawCanvas();
        };
    });

    canvas.addEventListener('mousedown', (e) => {
        if (resizing) return;
        const mouseX = e.offsetX;
        const mouseY = e.offsetY;
        draggingImage = images.find(img => mouseX >= img.x && mouseX <= img.x + img.width && mouseY >= img.y && mouseY <= img.y + img.height);

        if (draggingImage) {
            selectedImage = draggingImage;
            offsetX = mouseX - draggingImage.x;
            offsetY = mouseY - draggingImage.y;
            isDrawing = false;
            drawCanvas();
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (draggingImage) {
            draggingImage.x = e.offsetX - offsetX;
            draggingImage.y = e.offsetY - offsetY;
            drawCanvas();
        }
    });

    canvas.addEventListener('mouseup', () => {
        draggingImage = null;
    });

    // Check if cursor is over the resize handle
    function isOverResizeHandle(mouseX, mouseY, img) {
        return (
            mouseX >= img.x + img.width - resizeHandleSize &&
            mouseX <= img.x + img.width &&
            mouseY >= img.y + img.height - resizeHandleSize &&
            mouseY <= img.y + img.height
        );
    }

    // Draw all elements
    function drawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        lines.forEach(line => {
            ctx.strokeStyle = line.color;
            ctx.lineWidth = line.width;
            ctx.beginPath();
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(line.endX, line.endY);
            ctx.stroke();
        });
        images.forEach(img => {
            ctx.drawImage(img.img, img.x, img.y, img.width, img.height);
            if (selectedImage === img) {
                drawResizeHandle(img);
            }
        });
    }

    // Draw resize handle on image
    function drawResizeHandle(img) {
        ctx.fillStyle = 'blue';
        ctx.fillRect(img.x + img.width - resizeHandleSize, img.y + img.height - resizeHandleSize, resizeHandleSize, resizeHandleSize);
    }

    // Geolocation
    function startGeolocation() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(showPosition, handleError);
        } else {
            alert("Geolocation is not supported by your browser.");
        }
    }

    function showPosition(position) {
        const latitude = position.coords.latitude;
        const longitude = position.coords.longitude;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        ctx.fillStyle = 'blue';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.font = '14px Arial';
        ctx.fillText(`You are here: (${latitude.toFixed(4)}, ${longitude.toFixed(4)})`, centerX + 10, centerY - 10);
    }

    function handleError(error) {
        switch(error.code) {
            case error.PERMISSION_DENIED: alert("User denied the request for Geolocation."); break;
            case error.POSITION_UNAVAILABLE: alert("Location information is unavailable."); break;
            case error.TIMEOUT: alert("The request to get user location timed out."); break;
            case error.UNKNOWN_ERROR: alert("An unknown error occurred."); break;
        }
    }

    // Clear and save functions
    function clearCanvas() {
        lines = [];
        images = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function saveCanvas() {
        const link = document.createElement('a');
        link.download = 'my_map.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    }
</script>
</body>
</html>
